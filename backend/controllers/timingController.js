// AI-based Devotee Timing Tracker
const DevoteeTiming = require("../models/DevoteeTiming");

// Mock devotee tracking data with AI insights
let devoteeTrackingData = [
  {
    _id: "1",
    deviceId: "KUMBH_DEVICE_001",
    anonymousId: "anon_12345", // Privacy-first approach
    currentZone: "Main Ghat",
    coordinates: { lat: 25.4358, lng: 81.8463 },
    entryTime: new Date(Date.now() - 2700000).toISOString(), // 45 minutes ago
    aiAnalysis: {
      riskLevel: "High",
      predictedExitTime: new Date(Date.now() + 900000).toISOString(), // 15 minutes from now
      safetyScore: 25, // Out of 100
      timeSpentInHighRisk: 25, // minutes
      recommendedAction: "Send safety alert - maximum safe time exceeded",
      crowdDensityExposure: 85,
      heatStressRisk: "High",
      movementPattern: "Stationary", // Stationary, Slow Movement, Normal Movement
      similarPatternOutcomes: {
        successfulExits: 78,
        requiredAssistance: 22,
        emergencyEvacuations: 5,
      },
    },
    vitals: {
      estimatedAge: 65,
      mobility: "Limited", // Excellent, Good, Limited, Requires Assistance
      groupSize: 1,
      withChildren: false,
      hasElderly: true,
    },
    zones: [
      {
        zoneName: "Entry Gate",
        entryTime: new Date(Date.now() - 2700000).toISOString(),
        exitTime: new Date(Date.now() - 2400000).toISOString(),
        duration: 5, // minutes
      },
      {
        zoneName: "Main Ghat",
        entryTime: new Date(Date.now() - 2400000).toISOString(),
        exitTime: null,
        duration: 40, // current duration
      },
    ],
    alerts: [
      {
        timestamp: new Date(Date.now() - 600000).toISOString(),
        type: "Time Warning",
        message: "Devotee has spent 35 minutes in high-risk zone",
        severity: "Medium",
        autoGenerated: true,
      },
      {
        timestamp: new Date().toISOString(),
        type: "Safety Alert",
        message: "Maximum safe time exceeded - intervention recommended",
        severity: "High",
        autoGenerated: true,
      },
    ],
    privacy: {
      dataRetention: "24 hours",
      anonymized: true,
      consentStatus: "Implied", // App usage implies consent
      dataPoints: ["location", "timing", "movement_pattern"],
    },
    status: "Active",
    lastUpdate: new Date().toISOString(),
  },
  {
    _id: "2",
    deviceId: "KUMBH_DEVICE_002",
    anonymousId: "anon_67890",
    currentZone: "Puja Kendra 1",
    coordinates: { lat: 25.4368, lng: 81.8473 },
    entryTime: new Date(Date.now() - 1800000).toISOString(), // 30 minutes ago
    aiAnalysis: {
      riskLevel: "Medium",
      predictedExitTime: new Date(Date.now() + 1800000).toISOString(), // 30 minutes from now
      safetyScore: 65,
      timeSpentInHighRisk: 15,
      recommendedAction: "Monitor - approaching time limit",
      crowdDensityExposure: 70,
      heatStressRisk: "Medium",
      movementPattern: "Slow Movement",
      similarPatternOutcomes: {
        successfulExits: 92,
        requiredAssistance: 8,
        emergencyEvacuations: 1,
      },
    },
    vitals: {
      estimatedAge: 35,
      mobility: "Good",
      groupSize: 4,
      withChildren: true,
      hasElderly: false,
    },
    zones: [
      {
        zoneName: "Entry Gate",
        entryTime: new Date(Date.now() - 1800000).toISOString(),
        exitTime: new Date(Date.now() - 1650000).toISOString(),
        duration: 2.5,
      },
      {
        zoneName: "Puja Kendra 1",
        entryTime: new Date(Date.now() - 1650000).toISOString(),
        exitTime: null,
        duration: 27.5,
      },
    ],
    alerts: [],
    privacy: {
      dataRetention: "24 hours",
      anonymized: true,
      consentStatus: "Explicit", // User opted in through app
      dataPoints: ["location", "timing", "movement_pattern", "group_info"],
    },
    status: "Active",
    lastUpdate: new Date().toISOString(),
  },
  {
    _id: "3",
    deviceId: "KUMBH_DEVICE_003",
    anonymousId: "anon_11111",
    currentZone: "Safe Exit",
    coordinates: { lat: 25.4348, lng: 81.8453 },
    entryTime: new Date(Date.now() - 3600000).toISOString(), // 1 hour ago
    exitTime: new Date(Date.now() - 300000).toISOString(), // 5 minutes ago
    aiAnalysis: {
      riskLevel: "Completed",
      predictedExitTime: null,
      safetyScore: 95,
      timeSpentInHighRisk: 20,
      recommendedAction: "Visit completed successfully",
      crowdDensityExposure: 60,
      heatStressRisk: "Low",
      movementPattern: "Normal Movement",
      totalVisitDuration: 55, // minutes
      exitEfficiency: "Excellent",
      similarPatternOutcomes: {
        successfulExits: 98,
        requiredAssistance: 2,
        emergencyEvacuations: 0,
      },
    },
    vitals: {
      estimatedAge: 28,
      mobility: "Excellent",
      groupSize: 2,
      withChildren: false,
      hasElderly: false,
    },
    zones: [
      {
        zoneName: "Entry Gate",
        entryTime: new Date(Date.now() - 3600000).toISOString(),
        exitTime: new Date(Date.now() - 3480000).toISOString(),
        duration: 2,
      },
      {
        zoneName: "Main Ghat",
        entryTime: new Date(Date.now() - 3480000).toISOString(),
        exitTime: new Date(Date.now() - 2280000).toISOString(),
        duration: 20,
      },
      {
        zoneName: "Puja Kendra 1",
        entryTime: new Date(Date.now() - 2280000).toISOString(),
        exitTime: new Date(Date.now() - 900000).toISOString(),
        duration: 23,
      },
      {
        zoneName: "Safe Exit",
        entryTime: new Date(Date.now() - 900000).toISOString(),
        exitTime: new Date(Date.now() - 300000).toISOString(),
        duration: 10,
      },
    ],
    alerts: [],
    privacy: {
      dataRetention: "24 hours",
      anonymized: true,
      consentStatus: "Explicit",
      dataPoints: ["location", "timing", "movement_pattern"],
    },
    status: "Completed",
    lastUpdate: new Date(Date.now() - 300000).toISOString(),
  },
];

// AI safety algorithms
const calculateSafetyScore = (devotee) => {
  let score = 100;

  // Time-based risk
  const timeInZone = (new Date() - new Date(devotee.entryTime)) / (1000 * 60); // minutes
  if (timeInZone > 60) score -= 40;
  else if (timeInZone > 45) score -= 25;
  else if (timeInZone > 30) score -= 10;

  // Crowd density risk
  if (devotee.aiAnalysis.crowdDensityExposure > 80) score -= 20;
  else if (devotee.aiAnalysis.crowdDensityExposure > 60) score -= 10;

  // Mobility-based risk
  switch (devotee.vitals.mobility) {
    case "Requires Assistance":
      score -= 30;
      break;
    case "Limited":
      score -= 20;
      break;
    case "Good":
      score -= 5;
      break;
    case "Excellent":
      break;
  }

  // Age-based risk
  if (devotee.vitals.estimatedAge > 60) score -= 15;
  if (devotee.vitals.withChildren) score -= 10;

  return Math.max(0, Math.min(100, score));
};

const predictRiskLevel = (devotee) => {
  const safetyScore = calculateSafetyScore(devotee);
  const timeInZone = (new Date() - new Date(devotee.entryTime)) / (1000 * 60);

  if (safetyScore < 30 || timeInZone > 50) return "High";
  if (safetyScore < 60 || timeInZone > 35) return "Medium";
  return "Low";
};

const generateRecommendedAction = (devotee) => {
  const riskLevel = predictRiskLevel(devotee);
  const timeInZone = (new Date() - new Date(devotee.entryTime)) / (1000 * 60);

  switch (riskLevel) {
    case "High":
      if (timeInZone > 50)
        return "Immediate intervention required - locate and assist exit";
      if (devotee.vitals.mobility === "Requires Assistance")
        return "Deploy assistance team immediately";
      return "Send safety alert and guide to nearest exit";

    case "Medium":
      if (timeInZone > 40) return "Send gentle reminder about time limits";
      if (devotee.aiAnalysis.crowdDensityExposure > 70)
        return "Monitor closely - high crowd exposure";
      return "Continue monitoring - approaching limits";

    case "Low":
      return "Normal monitoring - safe parameters";

    default:
      return "Continue monitoring";
  }
};

// GET /api/timing - Get all active devotee tracking data
const getAllTimingData = async (req, res) => {
  try {
    const { status, riskLevel, zone } = req.query;

    let filteredData = [...devoteeTrackingData];

    if (status) {
      filteredData = filteredData.filter(
        (devotee) => devotee.status === status
      );
    }

    if (riskLevel) {
      filteredData = filteredData.filter(
        (devotee) => devotee.aiAnalysis.riskLevel === riskLevel
      );
    }

    if (zone) {
      filteredData = filteredData.filter(
        (devotee) => devotee.currentZone === zone
      );
    }

    // Update AI analysis for active devotees
    filteredData = filteredData.map((devotee) => {
      if (devotee.status === "Active") {
        return {
          ...devotee,
          aiAnalysis: {
            ...devotee.aiAnalysis,
            safetyScore: calculateSafetyScore(devotee),
            riskLevel: predictRiskLevel(devotee),
            recommendedAction: generateRecommendedAction(devotee),
            lastUpdate: new Date().toISOString(),
          },
        };
      }
      return devotee;
    });

    const analytics = {
      totalActive: filteredData.filter((d) => d.status === "Active").length,
      highRisk: filteredData.filter((d) => d.aiAnalysis.riskLevel === "High")
        .length,
      mediumRisk: filteredData.filter(
        (d) => d.aiAnalysis.riskLevel === "Medium"
      ).length,
      lowRisk: filteredData.filter((d) => d.aiAnalysis.riskLevel === "Low")
        .length,
      avgSafetyScore: Math.round(
        filteredData.reduce((sum, d) => sum + d.aiAnalysis.safetyScore, 0) /
          filteredData.length
      ),
      zonesWithHighRisk: [
        ...new Set(
          filteredData
            .filter((d) => d.aiAnalysis.riskLevel === "High")
            .map((d) => d.currentZone)
        ),
      ],
    };

    res.json({
      success: true,
      data: filteredData.sort(
        (a, b) => new Date(b.lastUpdate) - new Date(a.lastUpdate)
      ),
      analytics,
      message: "Devotee timing data retrieved successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Error retrieving timing data",
      error: error.message,
    });
  }
};

// POST /api/timing/track - Start tracking a new devotee (from mobile app)
const startTracking = async (req, res) => {
  try {
    const { deviceId, entryZone, userProfile } = req.body;

    // Check if device is already being tracked
    const existingTrack = devoteeTrackingData.find(
      (d) => d.deviceId === deviceId && d.status === "Active"
    );
    if (existingTrack) {
      return res.status(400).json({
        success: false,
        message: "Device already being tracked",
      });
    }

    const newId = String(
      Math.max(...devoteeTrackingData.map((item) => parseInt(item._id))) + 1
    );
    const anonymousId = `anon_${Date.now()}`;

    const newTracking = {
      _id: newId,
      deviceId,
      anonymousId,
      currentZone: entryZone || "Entry Gate",
      coordinates: { lat: 25.4348, lng: 81.8453 }, // Default entry coordinates
      entryTime: new Date().toISOString(),
      aiAnalysis: {
        riskLevel: "Low",
        predictedExitTime: new Date(Date.now() + 2400000).toISOString(), // 40 minutes default
        safetyScore: 95,
        timeSpentInHighRisk: 0,
        recommendedAction: "Normal monitoring - safe parameters",
        crowdDensityExposure: 30,
        heatStressRisk: "Low",
        movementPattern: "Normal Movement",
        similarPatternOutcomes: {
          successfulExits: 95,
          requiredAssistance: 5,
          emergencyEvacuations: 1,
        },
      },
      vitals: {
        estimatedAge: userProfile?.age || 35,
        mobility: userProfile?.mobility || "Good",
        groupSize: userProfile?.groupSize || 1,
        withChildren: userProfile?.withChildren || false,
        hasElderly: userProfile?.hasElderly || false,
      },
      zones: [
        {
          zoneName: entryZone || "Entry Gate",
          entryTime: new Date().toISOString(),
          exitTime: null,
          duration: 0,
        },
      ],
      alerts: [],
      privacy: {
        dataRetention: "24 hours",
        anonymized: true,
        consentStatus: "Explicit",
        dataPoints: ["location", "timing", "movement_pattern"],
      },
      status: "Active",
      lastUpdate: new Date().toISOString(),
    };

    devoteeTrackingData.push(newTracking);

    res.status(201).json({
      success: true,
      data: {
        trackingId: newTracking.anonymousId,
        safeTimeLimit: 40, // minutes
        recommendations: [
          "Stay hydrated",
          "Follow crowd flow indicators",
          "Exit if feeling unwell",
        ],
      },
      message: "Devotee tracking started successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Error starting tracking",
      error: error.message,
    });
  }
};

// PUT /api/timing/update/:anonymousId - Update devotee location/status
const updateDevoteeLocation = async (req, res) => {
  try {
    const { anonymousId } = req.params;
    const { newZone, coordinates, exitZone } = req.body;

    const devoteeIndex = devoteeTrackingData.findIndex(
      (d) => d.anonymousId === anonymousId
    );
    if (devoteeIndex === -1) {
      return res.status(404).json({
        success: false,
        message: "Tracking session not found",
      });
    }

    let devotee = devoteeTrackingData[devoteeIndex];

    // Handle zone exit
    if (exitZone) {
      const currentZoneIndex = devotee.zones.findIndex(
        (z) => z.zoneName === exitZone && !z.exitTime
      );
      if (currentZoneIndex !== -1) {
        devotee.zones[currentZoneIndex].exitTime = new Date().toISOString();
        devotee.zones[currentZoneIndex].duration =
          (new Date() - new Date(devotee.zones[currentZoneIndex].entryTime)) /
          (1000 * 60);
      }
    }

    // Handle zone entry
    if (newZone && newZone !== devotee.currentZone) {
      devotee.zones.push({
        zoneName: newZone,
        entryTime: new Date().toISOString(),
        exitTime: null,
        duration: 0,
      });
      devotee.currentZone = newZone;
    }

    // Update coordinates
    if (coordinates) {
      devotee.coordinates = coordinates;
    }

    // Update AI analysis
    devotee.aiAnalysis.safetyScore = calculateSafetyScore(devotee);
    devotee.aiAnalysis.riskLevel = predictRiskLevel(devotee);
    devotee.aiAnalysis.recommendedAction = generateRecommendedAction(devotee);

    // Check for new alerts
    const timeInCurrentZone = devotee.zones
      .filter((z) => z.zoneName === devotee.currentZone && !z.exitTime)
      .reduce(
        (sum, z) => sum + (new Date() - new Date(z.entryTime)) / (1000 * 60),
        0
      );

    if (timeInCurrentZone > 45 && devotee.aiAnalysis.riskLevel === "High") {
      devotee.alerts.push({
        timestamp: new Date().toISOString(),
        type: "Critical Time Alert",
        message: "Devotee has exceeded maximum safe time in zone",
        severity: "Critical",
        autoGenerated: true,
      });
    }

    devotee.lastUpdate = new Date().toISOString();
    devoteeTrackingData[devoteeIndex] = devotee;

    // Prepare response (excluding sensitive data)
    const responseData = {
      currentZone: devotee.currentZone,
      safetyScore: devotee.aiAnalysis.safetyScore,
      riskLevel: devotee.aiAnalysis.riskLevel,
      timeInZone: Math.round(timeInCurrentZone),
      recommendations: devotee.aiAnalysis.recommendedAction,
      newAlerts: devotee.alerts.filter(
        (alert) => new Date() - new Date(alert.timestamp) < 60000 // Last minute
      ),
    };

    res.json({
      success: true,
      data: responseData,
      message: "Location updated successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Error updating location",
      error: error.message,
    });
  }
};

// POST /api/timing/exit/:anonymousId - Complete tracking session
const exitTracking = async (req, res) => {
  try {
    const { anonymousId } = req.params;
    const { exitMethod = "Normal", feedback } = req.body;

    const devoteeIndex = devoteeTrackingData.findIndex(
      (d) => d.anonymousId === anonymousId
    );
    if (devoteeIndex === -1) {
      return res.status(404).json({
        success: false,
        message: "Tracking session not found",
      });
    }

    let devotee = devoteeTrackingData[devoteeIndex];

    // Complete current zone
    const currentZoneIndex = devotee.zones.findIndex((z) => !z.exitTime);
    if (currentZoneIndex !== -1) {
      devotee.zones[currentZoneIndex].exitTime = new Date().toISOString();
      devotee.zones[currentZoneIndex].duration =
        (new Date() - new Date(devotee.zones[currentZoneIndex].entryTime)) /
        (1000 * 60);
    }

    // Calculate total visit statistics
    const totalDuration =
      (new Date() - new Date(devotee.entryTime)) / (1000 * 60);
    const highRiskTime = devotee.zones
      .filter((z) => ["Main Ghat", "Puja Kendra 1"].includes(z.zoneName))
      .reduce((sum, z) => sum + (z.duration || 0), 0);

    devotee.exitTime = new Date().toISOString();
    devotee.status = "Completed";
    devotee.aiAnalysis.riskLevel = "Completed";
    devotee.aiAnalysis.totalVisitDuration = Math.round(totalDuration);
    devotee.aiAnalysis.timeSpentInHighRisk = Math.round(highRiskTime);
    devotee.aiAnalysis.exitEfficiency =
      totalDuration < 60
        ? "Excellent"
        : totalDuration < 90
        ? "Good"
        : "Needs Improvement";

    // Add completion summary
    const visitSummary = {
      totalDuration: Math.round(totalDuration),
      zonesVisited: devotee.zones.length,
      highRiskExposure: Math.round(highRiskTime),
      safetyScore: devotee.aiAnalysis.safetyScore,
      exitMethod,
      feedback: feedback || null,
    };

    devotee.visitSummary = visitSummary;
    devotee.lastUpdate = new Date().toISOString();

    devoteeTrackingData[devoteeIndex] = devotee;

    res.json({
      success: true,
      data: {
        visitSummary,
        message:
          exitMethod === "Emergency"
            ? "Emergency exit completed - data recorded for safety analysis"
            : "Thank you for your visit. Your data helps us improve safety for all devotees.",
        safetyTips: [
          "Remember to stay hydrated",
          "Follow official guidance",
          "Report any safety concerns",
        ],
      },
      message: "Tracking session completed successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Error completing tracking session",
      error: error.message,
    });
  }
};

// GET /api/timing/alerts - Get active safety alerts
const getTimingAlerts = async (req, res) => {
  try {
    const activeDevotees = devoteeTrackingData.filter(
      (d) => d.status === "Active"
    );

    const criticalAlerts = [];
    const warningAlerts = [];

    activeDevotees.forEach((devotee) => {
      const timeInZone =
        (new Date() - new Date(devotee.entryTime)) / (1000 * 60);

      if (devotee.aiAnalysis.riskLevel === "High" || timeInZone > 50) {
        criticalAlerts.push({
          anonymousId: devotee.anonymousId,
          zone: devotee.currentZone,
          riskLevel: devotee.aiAnalysis.riskLevel,
          timeInZone: Math.round(timeInZone),
          safetyScore: devotee.aiAnalysis.safetyScore,
          recommendedAction: devotee.aiAnalysis.recommendedAction,
          coordinates: devotee.coordinates,
          vitals: devotee.vitals,
        });
      } else if (devotee.aiAnalysis.riskLevel === "Medium" || timeInZone > 35) {
        warningAlerts.push({
          anonymousId: devotee.anonymousId,
          zone: devotee.currentZone,
          riskLevel: devotee.aiAnalysis.riskLevel,
          timeInZone: Math.round(timeInZone),
          safetyScore: devotee.aiAnalysis.safetyScore,
          recommendedAction: devotee.aiAnalysis.recommendedAction,
        });
      }
    });

    res.json({
      success: true,
      data: {
        critical: criticalAlerts.sort((a, b) => a.safetyScore - b.safetyScore),
        warnings: warningAlerts.sort((a, b) => a.safetyScore - b.safetyScore),
        summary: {
          totalActive: activeDevotees.length,
          criticalCount: criticalAlerts.length,
          warningCount: warningAlerts.length,
          averageSafetyScore: Math.round(
            activeDevotees.reduce(
              (sum, d) => sum + d.aiAnalysis.safetyScore,
              0
            ) / activeDevotees.length
          ),
        },
      },
      message: "Safety alerts retrieved successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Error retrieving alerts",
      error: error.message,
    });
  }
};

// GET /api/timing/analytics - Get comprehensive analytics
const getTimingAnalytics = async (req, res) => {
  try {
    const { timeRange = "24h" } = req.query;

    // Filter data based on time range
    const now = new Date();
    const timeRangeMs =
      timeRange === "1h"
        ? 3600000
        : timeRange === "6h"
        ? 21600000
        : timeRange === "12h"
        ? 43200000
        : 86400000; // 24h default

    const filteredData = devoteeTrackingData.filter(
      (d) => new Date(d.entryTime) > new Date(now - timeRangeMs)
    );

    const completed = filteredData.filter((d) => d.status === "Completed");
    const active = filteredData.filter((d) => d.status === "Active");

    // Calculate averages
    const avgVisitDuration =
      completed.length > 0
        ? Math.round(
            completed.reduce(
              (sum, d) => sum + (d.aiAnalysis.totalVisitDuration || 0),
              0
            ) / completed.length
          )
        : 0;

    const avgSafetyScore =
      filteredData.length > 0
        ? Math.round(
            filteredData.reduce((sum, d) => sum + d.aiAnalysis.safetyScore, 0) /
              filteredData.length
          )
        : 0;

    // Zone analytics
    const zoneStats = {};
    filteredData.forEach((devotee) => {
      devotee.zones.forEach((zone) => {
        if (!zoneStats[zone.zoneName]) {
          zoneStats[zone.zoneName] = {
            totalVisits: 0,
            avgDuration: 0,
            riskEvents: 0,
            totalDuration: 0,
          };
        }
        zoneStats[zone.zoneName].totalVisits++;
        zoneStats[zone.zoneName].totalDuration += zone.duration || 0;
      });
    });

    // Calculate averages for zones
    Object.keys(zoneStats).forEach((zoneName) => {
      zoneStats[zoneName].avgDuration = Math.round(
        zoneStats[zoneName].totalDuration / zoneStats[zoneName].totalVisits
      );
    });

    // Risk analysis
    const riskAnalysis = {
      high: filteredData.filter((d) => d.aiAnalysis.riskLevel === "High")
        .length,
      medium: filteredData.filter((d) => d.aiAnalysis.riskLevel === "Medium")
        .length,
      low: filteredData.filter((d) => d.aiAnalysis.riskLevel === "Low").length,
      completed: filteredData.filter(
        (d) => d.aiAnalysis.riskLevel === "Completed"
      ).length,
    };

    // Success metrics
    const successMetrics = {
      completionRate:
        filteredData.length > 0
          ? Math.round((completed.length / filteredData.length) * 100)
          : 0,
      emergencyExits: completed.filter(
        (d) => d.visitSummary?.exitMethod === "Emergency"
      ).length,
      avgExitEfficiency:
        completed.length > 0
          ? {
              excellent: Math.round(
                (completed.filter(
                  (d) => d.aiAnalysis.exitEfficiency === "Excellent"
                ).length /
                  completed.length) *
                  100
              ),
              good: Math.round(
                (completed.filter((d) => d.aiAnalysis.exitEfficiency === "Good")
                  .length /
                  completed.length) *
                  100
              ),
              needsImprovement: Math.round(
                (completed.filter(
                  (d) => d.aiAnalysis.exitEfficiency === "Needs Improvement"
                ).length /
                  completed.length) *
                  100
              ),
            }
          : { excellent: 0, good: 0, needsImprovement: 0 },
    };

    res.json({
      success: true,
      data: {
        overview: {
          totalTracked: filteredData.length,
          currentlyActive: active.length,
          completed: completed.length,
          avgVisitDuration,
          avgSafetyScore,
        },
        zoneAnalytics: zoneStats,
        riskDistribution: riskAnalysis,
        successMetrics,
        recommendations: [
          active.length > 50
            ? "High visitor volume - increase monitoring"
            : null,
          avgSafetyScore < 70
            ? "Below average safety scores - review crowd management"
            : null,
          riskAnalysis.high > 5
            ? "Multiple high-risk situations - deploy additional resources"
            : null,
        ].filter(Boolean),
        timeRange,
        generatedAt: new Date().toISOString(),
      },
      message: "Analytics generated successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Error generating analytics",
      error: error.message,
    });
  }
};

// Get all devotee timings
const getDevoteeTimings = async (req, res) => {
  try {
    const { status, location, search, date } = req.query;
    let filter = {};

    if (status) filter.status = status;
    if (location) filter.location = { $regex: location, $options: "i" };
    if (search) {
      filter.$or = [
        { name: { $regex: search, $options: "i" } },
        { phoneNumber: { $regex: search, $options: "i" } },
        { devoteeId: { $regex: search, $options: "i" } },
      ];
    }
    if (date) {
      const startDate = new Date(date);
      const endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + 1);
      filter.checkInTime = { $gte: startDate, $lt: endDate };
    }

    const timings = await DevoteeTiming.find(filter).sort({ checkInTime: -1 });
    res.json({ success: true, data: timings });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};

// Add new devotee timing
const addDevoteeTiming = async (req, res) => {
  try {
    const timing = new DevoteeTiming(req.body);
    const savedTiming = await timing.save();
    res.status(201).json({ success: true, data: savedTiming });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

// Update devotee timing
const updateDevoteeTiming = async (req, res) => {
  try {
    const updatedTiming = await DevoteeTiming.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    );
    if (!updatedTiming) {
      return res
        .status(404)
        .json({ success: false, message: "Timing record not found" });
    }
    res.json({ success: true, data: updatedTiming });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

// Delete devotee timing
const deleteDevoteeTiming = async (req, res) => {
  try {
    const deletedTiming = await DevoteeTiming.findByIdAndDelete(req.params.id);
    if (!deletedTiming) {
      return res
        .status(404)
        .json({ success: false, message: "Timing record not found" });
    }
    res.json({ success: true, message: "Timing record deleted successfully" });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};

// Check in devotee
const checkInDevotee = async (req, res) => {
  try {
    const {
      name,
      phoneNumber,
      location,
      purpose,
      groupSize,
      emergencyContact,
    } = req.body;

    const timing = new DevoteeTiming({
      devoteeId: `DEV${Date.now()}`,
      name,
      phoneNumber,
      location,
      purpose,
      groupSize,
      emergencyContact,
      checkInTime: new Date(),
      status: "checked_in",
    });

    const savedTiming = await timing.save();
    res.status(201).json({
      success: true,
      data: savedTiming,
      message: "Devotee checked in successfully",
    });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

// Check out devotee
const checkOutDevotee = async (req, res) => {
  try {
    const { id } = req.params;
    const checkOutTime = new Date();

    const timing = await DevoteeTiming.findById(id);
    if (!timing) {
      return res
        .status(404)
        .json({ success: false, message: "Timing record not found" });
    }

    const actualStayDuration = Math.floor(
      (checkOutTime - timing.checkInTime) / (1000 * 60)
    ); // in minutes

    const updatedTiming = await DevoteeTiming.findByIdAndUpdate(
      id,
      {
        checkOutTime,
        actualStayDuration,
        status: "checked_out",
      },
      { new: true }
    );

    res.json({
      success: true,
      data: updatedTiming,
      message: "Devotee checked out successfully",
    });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

// Get timing statistics
const getTimingStats = async (req, res) => {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const stats = await Promise.all([
      // Today's check-ins
      DevoteeTiming.countDocuments({
        checkInTime: { $gte: today, $lt: tomorrow },
      }),

      // Currently present
      DevoteeTiming.countDocuments({
        status: "checked_in",
      }),

      // Average stay duration
      DevoteeTiming.aggregate([
        {
          $match: {
            actualStayDuration: { $exists: true, $ne: null },
          },
        },
        {
          $group: {
            _id: null,
            avgStayDuration: { $avg: "$actualStayDuration" },
          },
        },
      ]),

      // Location-wise distribution
      DevoteeTiming.aggregate([
        {
          $match: { status: "checked_in" },
        },
        {
          $group: {
            _id: "$location",
            count: { $sum: 1 },
            totalGroupSize: { $sum: "$groupSize" },
          },
        },
        { $sort: { count: -1 } },
      ]),

      // Hourly check-in trend
      DevoteeTiming.aggregate([
        {
          $match: {
            checkInTime: { $gte: today, $lt: tomorrow },
          },
        },
        {
          $group: {
            _id: { $hour: "$checkInTime" },
            count: { $sum: 1 },
            totalPeople: { $sum: "$groupSize" },
          },
        },
        { $sort: { _id: 1 } },
      ]),
    ]);

    res.json({
      success: true,
      data: {
        todayCheckIns: stats[0],
        currentlyPresent: stats[1],
        avgStayDuration: Math.round(stats[2][0]?.avgStayDuration || 0),
        locationDistribution: stats[3],
        hourlyTrend: stats[4],
        lastUpdated: new Date().toISOString(),
      },
    });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};

// Search devotee by QR code or phone
const searchDevotee = async (req, res) => {
  try {
    const { query } = req.params;

    const devotee = await DevoteeTiming.findOne({
      $or: [{ qrCode: query }, { phoneNumber: query }, { devoteeId: query }],
    });

    if (!devotee) {
      return res.status(404).json({
        success: false,
        message: "Devotee not found",
      });
    }

    res.json({ success: true, data: devotee });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};

module.exports = {
  getDevoteeTimings,
  addDevoteeTiming,
  updateDevoteeTiming,
  deleteDevoteeTiming,
  checkInDevotee,
  checkOutDevotee,
  getTimingStats,
  searchDevotee,
  // Add the new AI tracking functions
  getAllTimingData,
  startTracking,
  updateDevoteeLocation,
  exitTracking,
  getTimingAlerts,
  getTimingAnalytics,
  // Add aliases for route compatibility
  getTimings: getDevoteeTimings,
  addTiming: addDevoteeTiming,
  updateTiming: updateDevoteeTiming,
  deleteTiming: deleteDevoteeTiming,
};
